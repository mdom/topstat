#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Curses;
use IO::Select;

our $VERSION = '0.01';

my %elements;
my $formats;

my %options = (
	delimiter => ' ',
	interval  => 2,
);
GetOptions( \%options, "format=s", "metric=s@", "delimiter=s", "interval=i" )
  or pod2usage(2);

%options = (
    format => '%10.2f',
    metric => [ 'count', 'average', 'sum' ],
    %options,
);

my $order_by = $options{metric}->[0];
my $eof = 0;

my %formats = (
    count => {
        header      => "Count",
        data_format => '%d',
    },
    sum => {
        header      => "Sum",
        data_format => $options{format},
    },
    average => {
        header      => "Average",
        data_format => $options{format},
    },
    min => {
        header      => "Minimum",
        data_format => $options{format},
    },
    max => {
        header      => "Maximum",
        data_format => $options{format},
    },
    last_seen => {
        header      => "Last seen",
        data_format => '%d',
    },
);
%formats = compute_formats();

if ( -t *STDIN ) {
    die "$0: stdin has to be connected to a file or pipe. Exiting.\n";
}

## dup stdin so curses can get stdin and we can process lines
## from the dupped stdin

open( my $pipe, '<&', *STDIN ) or die "$!\n";
open( STDIN, '<', '/dev/tty' );

my $select = IO::Select->new();
$select->add($pipe,\*STDIN);

$SIG{ALRM} = sub { update_curses(); alarm $options{interval}; };
alarm $options{interval};

init_curses();

while (1) {
	my @ready = $select->can_read;
	foreach my $fh ( @ready ) {
		if ( $fh == \*STDIN ) {
			process_stdin();
		}
		elsif ( $fh == $pipe ) {
			my $line = <$pipe>;
			process_line($line,\%elements);
		}
	}
}

exit 0;

sub process_line {
    my ( $line, $elements ) = @_;
    my ( $element, $number ) = split( $options{delimiter}, $line );
    return if !defined($element) || !defined($number);
    if ( !exists $elements->{$element} ) {
        $elements->{$element} = {
            max     => $number,
            min     => $number,
            count   => 1,
            element => $element,
            sum     => $number,
            average => $number,
        };
    }
    else {
        my $elt = $elements->{$element};
        $elt->{count}++;
        $elt->{sum} += $number;
        $elt->{max} = $elt->{max} < $number ? $number : $elt->{max};
        $elt->{min} = $elt->{min} > $number ? $number : $elt->{min};
        $elt->{average} =
          ( $elt->{average} * ( $elt->{count} - 1 ) + $number ) / $elt->{count};
    }
    $elements->{$element}->{last_seen} = time();
    return;
}

sub compute_formats {
    for my $metric ( keys %formats ) {
        my $header = $formats{$metric}->{header};
        my $format = $formats{$metric}->{data_format};
        if (
            $format =~ m{
		^%?
		(?<format>
			(?<flags>[-+0\#]*)
			(?<width>\d*)
			(?<precision>\.\d*)?
			(?<conversion>[A-Za-z])
		)
	     }smx
          )
        {

            my $header_length = length($header);
            my $column_width  = $header_length;
            if ( $+{width} ) {
                $column_width =
                  $+{width} > $header_length ? $+{width} : $header_length;
            }

            my $align = index( $+{flags}, '-' ) != -1 ? '-' : '';

            $formats{$metric}->{header_format} = "%${align}${column_width}s";
            $formats{$metric}->{data_format} =
                '%'
              . ( $+{flags} || '' )
              . ${column_width}
              . ( $+{precision} || '' )
              . $+{conversion};
        }
    }
    return %formats;
}

sub init_curses {
    initscr();
    clear();
    noecho();
    cbreak();    # Line buffering disabled. pass on everything
    nodelay(1);
}

sub process_stdin {
    my $key = getch();
    if ( $key eq 'q' ) {
        exit 0;
    }
    elsif ( $key eq 'c' ) {
        $order_by = 'count';
    }
    elsif ( $key eq 'a' ) {
        $order_by = 'average';
    }
    elsif ( $key eq 's' ) {
        $order_by = 'sum';
    }
    elsif ( $key eq 'l' ) {
        $order_by = 'last_seen';
    }
    elsif ( $key eq 'C' ) {
        close($pipe);
    }
    return;
}

sub update_curses {
    erase();
    my ( $height, $width );
    getmaxyx( $height, $width );
    my @metrics = @{ $options{metric} };

    my @top_ten_count =
      sort { $b->{$order_by} <=> $a->{$order_by} } values %elements;

    my $count = @top_ten_count;

    attron(A_STANDOUT);
    my @header = map { $formats{$_}->{header} } @metrics;
    my $header_format =
      join( ' ', map { $formats{$_}->{header_format} } @metrics );
    my $header = sprintf( $header_format, @header );
    my $rest = $width - length($header) - 1;
    $header .= sprintf( " %-${rest}s", "Element" );
    addstr($header);
    attroff(A_STANDOUT);

    for my $val ( @top_ten_count[ 0 .. $height - 3 ] ) {
        next if !$val->{sum};
        next if !$val->{element};
        my @elts = map { $val->{$_} } @metrics;
        my $line_format =
          join( ' ', map { $formats{$_}->{data_format} } @metrics );
        my $line = sprintf( $line_format, @elts );
        my $rest = $width - length($line) - 1;
        $line .= sprintf( " %-${rest}.${rest}s", $val->{element} );
        addstr($line);
    }
    attron(A_STANDOUT);
    my $prefix = $eof ? "EOF    " : "READING";
    my $status = "$prefix Count: $count";
    addstr(sprintf("%-${width}s",$status));

    attroff(A_STANDOUT);
    refresh();
}

END {
    endwin();
}

1;

__END__

=pod

=head1 NAME

topstat - simple statics for stdin with top-like interface

=head1 SYNOPSIS

  data | topstat --metric count --metric average 
  data | topstat --metric --metric average --format '%10.4f'

=head1 DESCRIPTION

topstat reads lines from stdin, generates statitics from these lines and
present them in a top-like interface. Every line must contain a number
as first element, the rest of the line is interpreted as identifier for
that line. Number and identifier are split by consecutive whitespace.

=head1 OPTIONS

=over 4 

=item -m, --metric METRIC

Selects what metrics to display and in what order. Possible values are
I<sum>, I<average>, I<count>, I<last-seen>, I<min> and I<max>. Defaults
to I<count>.

=item -i, --interval INTERVAL

Delay between screen updates in seconds. Default to 2.

=item -d, --delimiter DELIMITER

Use DELIMITER instead of consecutive whitespace as delimiter of fields.

=head1 INSTALLATION

It is possible to install this script via perl normal install routines. 

  perl Build.PL
  ./Build
  ./Build install

Or you can just copy the script somewhere in your path and install the
dependencies via your normal package system. For example, in Debian:

  apt-get install libcurses-perl

=head1 COPYRIGHT AND LICENSE

Copyright 2014 Mario Domgoergen L<E<lt>mario@domgoergen.comE<gt>>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
